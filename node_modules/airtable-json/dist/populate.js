function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import "core-js/modules/es.promise.js";
import "core-js/modules/es.array.reduce.js";
import "core-js/modules/es.array.iterator.js";
import "core-js/modules/web.dom-collections.iterator.js";
import "core-js/modules/esnext.set.add-all.js";
import "core-js/modules/esnext.set.delete-all.js";
import "core-js/modules/esnext.set.difference.js";
import "core-js/modules/esnext.set.every.js";
import "core-js/modules/esnext.set.filter.js";
import "core-js/modules/esnext.set.find.js";
import "core-js/modules/esnext.set.intersection.js";
import "core-js/modules/esnext.set.is-disjoint-from.js";
import "core-js/modules/esnext.set.is-subset-of.js";
import "core-js/modules/esnext.set.is-superset-of.js";
import "core-js/modules/esnext.set.join.js";
import "core-js/modules/esnext.set.map.js";
import "core-js/modules/esnext.set.reduce.js";
import "core-js/modules/esnext.set.some.js";
import "core-js/modules/esnext.set.symmetric-difference.js";
import "core-js/modules/esnext.set.union.js";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

import keyBy from "lodash.keyby";
import chunk from "lodash.chunk";
import airtableJson from "./airtable-json.js";
var max_ids_per_query = 40;
export default function (_x) {
  return _ref2.apply(this, arguments);
}

function _ref2() {
  _ref2 = _asyncToGenerator(function* (_ref) {
    var {
      auth_key,
      base_name,
      local,
      other,
      things,
      flatten = false,
      as
    } = _ref;
    var foreign_ids = things.reduce((acc, thing) => {
      if (thing[local]) {
        return acc.concat(thing[local]);
      }

      return acc;
    }, []);
    foreign_ids = [...new Set(foreign_ids)];
    var comparisons = foreign_ids.map(id => "RECORD_ID() = '".concat(id, "'"));
    var chunked_comparisons = chunk(comparisons, max_ids_per_query);
    var all_results = [];

    for (var c of chunked_comparisons) {
      var filterByFormula = "OR(".concat(c.join(", "), ")");
      var results = yield airtableJson({
        auth_key,
        base_name,
        primary: other,
        filter: filterByFormula
      });
      all_results = all_results.concat(results);
    }

    all_results = keyBy(all_results, "__id");
    var new_things = things.map(thing => {
      if (thing[local]) {
        var _all_results, _thing$local;

        var transformed = flatten ? (_all_results = all_results) === null || _all_results === void 0 ? void 0 : _all_results[(_thing$local = thing[local]) === null || _thing$local === void 0 ? void 0 : _thing$local[0]] : thing[local].map(id => all_results[id]);

        if (as) {
          var return_val = _objectSpread(_objectSpread({}, thing), {}, {
            [as]: transformed
          });

          delete return_val[local];
          return return_val;
        }

        return _objectSpread(_objectSpread({}, thing), {}, {
          [local]: transformed
        });
      }

      return thing;
    });
    return new_things;
  });
  return _ref2.apply(this, arguments);
}